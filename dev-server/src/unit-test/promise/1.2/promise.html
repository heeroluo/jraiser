<!DOCTYPE HTML>
<html>

<head>
	<meta charset="utf-8" />
	<title>单元测试:promise</title>
	<link href="/non-modular/qunit/qunit.css" rel="stylesheet" type="text/css">
	<style>
	</style>
</head>

<body>
	<div id="qunit"></div>
	<div id="qunit-fixture"></div>
	<script src="/non-modular/bowljs/bowl.js"></script>
	<script src="/non-modular/bowl-config.js"></script>
	<script src="/non-modular/qunit/qunit.js"></script>
	<script src="/non-modular/test-utils.js"></script>
	<script>
		require(['promise/1.2/promise'], function(Promise) {
			// 批量生产promise，减少重复代码
			function promiseFactory() {
				var p1 = new Promise(function(resolve, reject) {
					setTimeout(() => {
						resolve('p1');
					}, 300);
				});
				var p2 = new Promise(function(resolve, reject) {
					setTimeout(() => {
						resolve('p2');
					}, 200);
				});
				var p3 = new Promise(function(resolve, reject) {
					setTimeout(() => {
						resolve('p3');
					}, 100);
				});
				var p4 = new Promise(function(resolve, reject) {
					setTimeout(() => {
						reject('p4');
					}, 200);
				});

				return [
					p1,
					p2,
					p3,
					p4
				];
			}

			QUnit.test('测试Promise处理任务的异步顺序', function(assert) {
				var done = assert.async();
				var p1 = new Promise(function(resolve, reject) {
					setTimeout(() => {
						resolve();
					}, 300);
				});
				
				var p2 = new Promise(function(resolve, reject) {
					setTimeout(() => {
						resolve();
					}, 200);
				});

				// 用于识别顺序
				var queue = [];
				setTimeout(() => {
					queue.push('p3');
				}, 100);

				p1.then(function() {
					queue.push('p1');
				});
				p2.then(function() {
					queue.push('p2');
				});

				setTimeout(function() {
					assert.equal(queue.toString(), ['p3', 'p2', 'p1'].toString());
					done();
				}, 500);
			});
			QUnit.test('测试resolve和reject是否正常调用', function(assert) {
				var done = assert.async();

				var testData = promiseFactory();
				var res1;
				var res2;

				testData[0].then(function() {
					assert.ok(true, '无reject时表现正常');
				}).catch(function() {
					assert.ok(false, '错误情况');
				});
				testData[3].then(function() {
					assert.ok(false, '错误情况');
				}).catch(function() {
					assert.ok(true, '有reject时表现正常');
				});

				setTimeout(() => {
					done();
				}, 500);
			});
			QUnit.test('测试finally', function(assert) {
				var done = assert.async();

				var testData = promiseFactory();
				var res1;
				var res2;

				testData[0].finally(function() {
					res1 = true;
				});
				testData[3].finally(function() {
					res2 = true;
				});
				
				setTimeout(function() {
					assert.equal(!res1 && !res2, true, '时间还没到');
				}, 0);

				setTimeout(function() {
					assert.equal(res1 && res2, true, ' 时间到');
					done();
				}, 500);
			});
			QUnit.test('测试方法all & spread', function(assert) {
				var done = assert.async();
				var testData = promiseFactory();

				// 有reject的情况
				Promise.all(testData).then(function(res) {
					assert.ok(false, '错误情况');
				}).catch(function(err) {
					assert.equal(err, 'p4', '有reject的情况下all表现正常');
				});

				var testData2 = promiseFactory();
				// 去掉reject的
				testData2.splice(3, 1);
				Promise.all(testData2).then(function(res) {
					assert.equal(res, ['p1', 'p2', 'p3'].toString(), '全是resolve的情况all表现正常')
				}).catch(function() {
					assert.ok(false, '错误情况');
				});

				var p1 = new Promise(function(resolve, reject) {
					setTimeout(() => {
						resolve([1, 2, 3]);
					}, 300);
				});

				p1.spread(function(res1, res2, res3) {
					var res = res1 === 1 && res2 === 2 && res3 === 3;
					assert.equal(res, true, 'spread是否正确传参');
				}).catch(function() {
					assert.ok(false, '错误情况');
				});

				setTimeout(function() {
					done();
				}, 500);
			});

			QUnit.test('测试方法series', function(assert) {
				var done = assert.async();
				// 用于测试串行过程
				var arr = [];

				// 测试无reject只有resolve
				Promise.series([
					function() {
						return new Promise(function(resolve, reject) {
							arr.push('p1');
							setTimeout(function() {
								resolve('p1');
							}, 200);
						});
					},
					function() {
						return new Promise(function(resolve, reject) {
							arr.push('p2');
							setTimeout(function() {
								resolve('p2');
							}, 100);
						});
					}
				]).then(function(res) {
					let boolean = (res === 'p2' && arr.toString() === ['p1', 'p2'].toString());
					assert.equal(boolean, true, '无reject时series表现正常');
				}).catch(function(err) {
					assert.ok(false, '错误情况');
				});

				// 测试有reject和resolve
				Promise.series([
					function() {
						return new Promise(function(resolve, reject) {
							setTimeout(function() {
								resolve('p1');
							}, 200);
						});
					},
					function() {
						return new Promise(function(resolve, reject) {
							setTimeout(function() {
								resolve('p2');
							}, 100);
						});
					},
					function() {
						return new Promise(function(resolve, reject) {
							setTimeout(function() {
								reject('p3');
							}, 100);
						});
					}
				]).then(function(res1) {
					assert.ok(false, '错误情况');
				}).catch(function(err) {
					assert.equal(err, 'p3', '测试有reject时series表现正常');
				})

				setTimeout(function() {
					done();
				}, 1000);
			});
		});
	</script>
</body>

</html>